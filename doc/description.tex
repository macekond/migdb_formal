\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{semantic}

\begin{document}

\section{Application model}
The application is a set of instances which cooperates together. Each instance is defined according to a class, it means the class defines the structure, relationships of the instance\footnote{we use notation $instance \lhd class$ to describe the fact instance is defined according a class}.

The application model consists of model of classes -structural model and of instances - data model. The whole application is described as:

\begin{verbatim}
op application : List{Class} List{Instance} -> Application [ctor] .
\end{verbatim}
The application is considered to be consistent if all instances are created according a class existing in the application. 

$\forall i \in instances(Application), \exists c \in classes(Application): i \lhd c $


\subsection{Application structure}
The structure of the application is defined by five concepts. Each concept is described and its constructor is introduced.

\begin{itemize}
	\item Class : Class represents a basic structural concept in the application model. It has a unique name, one or more properties and a class can be associated to other classes in the application.  
	\begin{verbatim}
op class : Qid List{Property} List{Association} -> Class [ctor] .
\end{verbatim}
	\item Property : Property represents a feature of  a class which is can be represented as a primitive type. The property can be mandatory, can have a default value.
	\begin{verbatim}
op property : Qid App-Type String Nat -> Property [ctor] .
\end{verbatim}
	\item Association : the association represents a connection between two classes. It has a unique name and it contains a name of the class which is referenced by the association. The class which owns the association is consider to be a starting class of an association, referenced class is consider to be an ending class of an association. The cardinalities defines the multiplicity of the association.
	\begin{verbatim}
op association : Qid Qid Nat Nat -> Association [ctor] .
\end{verbatim}
	\item App-Type : represents primitive types in the application. There are usually defined types such as String, Integer, Boolean etc. in contrast there is only one type in our model, because we focus on structural and data changes and type casting operations are not important for us. The only App-Type type is called APP-STRING.
	\begin{verbatim}
op APP-STRING : -> App-Type [ctor] .
	\end{verbatim}
\end{itemize}
An summary of application model:
\begin{verbatim}
Class = <label, property*, association*>
Property = <label, App-Type, defaultValue, cardinality>
Association = <label, referencedClass, startCardinality, 
              endCardinality>
              
App-Type = APP-STRING 
cardinality = NzNat
referencesClass = label
startCardinality = NzNat
endCardinality = NzNat
Bool = true | false
NzNat = [0 - 9]*
\end{verbatim}

\subsection{Application Structure Evolution}
The evolution of the application persistent layer is called refactoring. In this section we provide an overview of refactorings allowed in our ORM system.

\subsubsection{Add Class}
$
\inference[AddClass(C, A)=]{\forall c \in classes(A) : c.name != C.name}
{application(classes(A) \cup C, instances(A))}
$

\begin{verbatim}
op addClass : Class Application -> Application .
ceq addClass(C, A) = errApplication("inconsistent", A) 
   if containsName(classes(A), name(C))  
   or not referencesExist(associations(C), classes(A)) .
eq addClass(C, A) = application(classes(A) C, instances(A)) .
\end{verbatim}



\section{Database model}
The relational database consists of database schema which defines the structure of the database and data. The database is a pair od sets:
\begin{verbatim}
op database : List{Table} List{Row} -> Database [ctor] .
\end{verbatim}

\subsection{Database Schema Model}
The database schema model is defined by following concepts:
\begin{itemize}
	\item Table: table represents a basic concept of database schema. It has a unique name, one or more column and it can be related to other tables in the schema by foreign keys. Rows in the table represents stored data.
	\begin{verbatim}
op table : Qid PrimaryKey List{Column} List{ForeignKey} -> Table [ctor].
	\end{verbatim}
	\item Column : columns define possible data values and types which can be part of a table record.
	\begin{verbatim}
op column : Qid Db-Type List{Constraint} -> Column [ctor] .
	\end{verbatim}

	\item Foreign key:
	\begin{verbatim}
op foreignKey : Qid Qid List{Constraint} -> ForeignKey [ctor] .
	\end{verbatim}

	\item Primary key:
	\begin{verbatim}
op primaryKey : Qid -> PrimaryKey [ctor] . 	
	\end{verbatim}

	\item Db-Type: represents primitive types in the database. There are usually defined types such as Char, Integer, Boolean etc. There is only one type defined in the model which is called DB-STRING.
	\begin{verbatim}
op DB-STRING : -> Db-Type [ctor] .
	\end{verbatim}

	\item Constraint: there are two types of constraints defined in the model. Both constraints are column constraints - first constraint defines unique records in a column, second constraint defines non-empty columns.
	\begin{verbatim}
op NOTNULL : -> Constraint [ctor] .
op UNIQUE : -> Constraint [ctor] .
	\end{verbatim}
\end{itemize}
A summary of database model:
\begin{verbatim}
Table = < name, PK, column*, foreignKey* >	
Column = < name, type, constraint* >
PrimaryKey = name
ForeignKey = < name, referencedTableName, constraint* >
Constraint = NOTNULL | UNIQUE 
Db-Type = DB-STRING
\end{verbatim}

\subsection{Database Schema Evolution}
\subsubsection{AddTable}

$
\inference[AddTable(T, D)=]{\forall t \in tables(D) : t.name != T.name\\
	\forall f \in T.foreignKeys, \exists t in T.tables : f.reference == t.name
}{database(T \cup tables(D), data(D))}
$

\begin{verbatim}
op addTable : Table Database -> Database .
ceq addTable(T, D) = errDatabase("inconsistent", D) 
   if containsName(tables(D), name(T)) 
   or (foreignKeys(T) =/= [] 
   and not referencesExist(foreignKeys(T), tables(D))) .
eq addTable(T, D) = database(tables(D) T, data(D)) .
\end{verbatim}


\section{Data Evolution in ORM System}
The Object-Relational system consist of an application and a database. The system has to be in consistent state. The extended object-relational mapping helps to assure consistency of the system.
\begin{verbatim}
op system : Application Database -> OrmSystem [ctor] .
\end{verbatim}
%TODO define consistency
Each eORM function applied on an ORM system produces a new generation of the system. If the new generation is consistent it can be used and evolved, otherwise the system cannot be evolved.

\subsection{Creating Evolution}
Creational operations does not have impact on stored data they change the structure of the application and database by adding new objects into model.

\subsubsection{Add Class}
The function addClass adds new class into an application and its equivalent into database. 
\begin{verbatim}
op addClass : Class OrmSystem -> OrmSystem .
eq addClass(C, system(A, D)) = system(addClass(C, A), 
   addClass2Db(C, D)) .

op addClass2Db : Class Database -> Database .
eq addClass2Db(C, D) = associations2db(name(C), 
   associations(C), addTables(collections2tables(name(C), 
   collectionPropertyList(C)), addTable(class2table(C), D))) .
\end{verbatim}

There is limitation connected with the implementation of platform. If there is a collection with the same name already existing table the evolution fails.

\subsection{Removing Evolution}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage
\appendix
\section{Object-Relational Mapping}
There are defined functions for object-relational mapping used in the model. The purpose of a function is indicated in its name and should be obvious from its definition. These functions do not serve for full object-relational mapping, their purpose is to help with data evolution and its propagation from application to database.

\subsection{Mapping of Types}
The mapping of types assumes a bijection between application types and database types, otherwise these has to be additional information for type mapping. We focus on structural and data change therefore we simplify types and its mapping.
\begin{verbatim}
op type2type : App-Type -> Db-Type .

eq type2type(APP-STRING) = DB-STRING .
\end{verbatim}

\subsection{Class Mapping}
We assume the primary key column is created automatically by database, therefore the primary key is always created with name Id and od NzNat type and properties with cardinality 0 or 1 are mapped into columns. The associations are ignored int this mapping as it is one of the partial mapping function used in eORM.

\begin{verbatim}
op class2table : Class -> Table .

eq class2table(C) = table(name(C), primaryKey('Id), 
                    props2cols(singlePropertyList(C)), []) .
\end{verbatim}

\subsection{Mapping of Properties}
There are two types of properties - the first type called single properties has cardinality 0 or 1, the second one (called collections) has cardinality greater than 1. Each type has its own rules of mapping.

\subsubsection{Mapping of Single Property}
Each single property is mapped to a column, when the cardinality is equal to 1 the NOTNULL constraint is added to a column. 
\begin{verbatim}
op props2cols : List{Property} -> List{Column} .
op props2cols : Property -> Column .

eq props2cols([]) = ([]).List{Column} .
ceq props2cols(Prop) = [] if cardinality(Prop) > 2 .
ceq props2cols(Prop) = column(name(Prop), type2type(type(Prop)), NOTNULL)
    if cardinality(Prop) == 1 .
ceq props2cols(Prop) = column(name(Prop), type2type(type(Prop)), []) 
   if cardinality(Prop) == 0 .
eq props2cols(Props) = props2cols(head(Props)) props2cols(tail(Props)) .
\end{verbatim}
A property with cardinality greater than one has to be mapped int a table not a column, thus we have a special mapping function for collections.

\subsubsection{Mapping of Collections}
A property collection is mapped into a table which contains a foreign key. The key references the table representing the owning class.
\begin{verbatim}
op collections2tables : Qid List{Property} -> List{Table} .
op collections2tables : Qid Property -> Table . 

eq collections2tables(Q, []) = ([]).List{Table} .
eq collections2tables(Q, Prop) = table(name(Prop), primaryKey('Id), 
   column('value, type2type(type(Prop)), [] ), foreignKey(Q, Q, NOTNULL)) .
eq collections2tables(Q, Props) = collections2tables(Q, head(Props)) 
   collections2tables(Q, tail(Props)) .
\end{verbatim}

\subsection{Mapping of Associations}
A association is mapped into database as a foreign key in table representing associating class or an association can be mapped as a coupling table in case the association cardinality is M:N or 1:N . 
\begin{verbatim}
op associations2db : Qid List{Association} Database -> Database .
op associations2db : Qid Association Database -> Database .
	
eq associations2db(Q, [], D) = D .
eq associations2db(Q, Assoc, EDb) = EDb .
ceq associations2db(Q, Assoc, D) = addFK(foreignKey(name(Assoc), Q, NOTNULL), 
	   referenceA(Assoc), D) if startCardinality(Assoc) < 2 . 
eq associations2db(Q, Assoc, D) = addTable(table(name(Assoc), 
   primaryKey('Id'), [], 
   foreignKey(Q, Q, NOTNULL) 
   foreignKey(name(Assoc), name(Assoc), NOTNULL)), D) .
	eq associations2db(Q, Assoc, D) = associations2db(Q, tail(Assoc), 
   associations2db(Q, head(Assoc), D)) .
\end{verbatim}



	



\end{document}
