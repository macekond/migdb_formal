\documentclass[11pt]{article}
\usepackage{amssymb}

\begin{document}

\section{Application model}
The application is a set of instances which cooperates together. Each instance is defined according to a class, it means the class defines the structure, relationships of the instance\footnote{we use notation $instance \lhd class$ to describe the fact instance is defined according a class}.

The application model consists of model of classes -structural model and of instances - data model. The whole application is described as:

\begin{verbatim}
op application : List{Class} List{Instance} -> Application [ctor] .
\end{verbatim}
The application is considered to be consistent if all instances are created according a class existing in the application. 

$\forall i \in instances(Application), \exists c \in classes(Application): i \lhd c $


\subsection{Application structure}
The structure of the application is define by five concepts:
\begin{itemize}
	\item Class : Class represents a basic structural concept in the application model. It has a unique name, one or more properties and a class can be associated to other classes in the application.  
	\item Property : Property represents a feature of  a class which is can be represented as a primitive type. The property can be mandatory, can have a default value
	\item Association : the association represents a connection between two classes. It has a unique name and it contains a name of the class which is referenced by the association. The class which owns the association is consider to be a starting class of an association, referenced class is consider to be an ending class of an association. The cardinalities defines the multiplicity of the association.
	\item App-Type : represents primitive types in the application. There are usually defined types such as String, Integer, Boolean etc. in contrast there is only one type in our model, because we focus on structural and data changes and type casting operations are not important for us. The only App-Type type is called APP-STRING.
\end{itemize}

\begin{verbatim}
Class = <label, property*, association*>
Property = <label, App-Type, defaultValue, cardinality>
Association = <label, referencedClass, startCardinality, 
              endCardinality>
App-Type = APP-STRING 
cardinality = NzNat
referencesClass = label
startCardinality = NzNat
endCardinality = NzNat
Bool = true | false
NzNat = [0 - 9]*
\end{verbatim}

\section{Database model}
The relational database consists of database schema which defines the structure of the database and data. The database is a pair od sets:
\begin{verbatim}
op database : List{Table} List{Row} -> Database [ctor] .
\end{verbatim}

\subsection{Database Schema Model}
The database schema model is defined by following concepts:
\begin{itemize}
	\item Table : table represents a basic concept of database schema. It has a unique name, one or more column and it can be related to other tables in the schema by foreign keys. Rows in the table represents stored data.
	\item Column : columns define possible data values and types which can be part of a table record.
	\item Foreign key :
	\item Primary key :
	\item Db-Type : represents primitive types in the database. There are usually defined types such as Char, Integer, Boolean etc. There is only one type defined in the model which is called DB-STRING.
	\item Constraint : there are two types of constraints defined in the model. Both constraints are column constraints - first constraint defines unique records in a column, second constraint defines non-empty columns.
\end{itemize}

	


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\appendix
\section{Object-Relational Mapping}
There are defined functions for object-relational mapping used in the model. The purpose of a function is indicated in its name and should be obvious from its definition.

\subsection{Mapping of Types}
The mapping of types assumes a bijection between application types and database types, otherwise these has to be additional information for type mapping. We focus on structural and data change therefore we simplify types and its mapping.
\begin{verbatim}
op type2type : App-Type -> Db-Type .

eq type2type(APP-STRING) = DB-STRING .
\end{verbatim}

\subsection{Class Mapping}
We assume the primary key column is created automatically by database, therefore the primary key is always created with name Id and od NzNat type and properties with cardinality 0 or 1 are mapped into columns. The associations are ignored int this mapping as it is one of the partial mapping function used in eORM.

\begin{verbatim}
op class2table : Class -> Table .

eq class2table(C) = table(name(C), primaryKey('Id), 
                    props2cols(singlePropertyList(C)), []) .
\end{verbatim}

\subsection{Mapping of Properties}
There are two types of properties - the first type called single properties has cardinality 0 or 1, the second one (called collections) has cardinality greater than 1. Each type has its own rules of mapping.

\subsubsection{Mapping of Single Property}
Each single property is mapped to a column, when the cardinality is equal to 1 the NOTNULL constraint is added to a column. 
\begin{verbatim}
op props2cols : List{Property} -> List{Column} .
op props2cols : Property -> Column .

eq props2cols([]) = ([]).List{Column} .
ceq props2cols(Prop) = [] if cardinality(Prop) > 2 .
ceq props2cols(Prop) = column(name(Prop), type2type(type(Prop)), NOTNULL)
    if cardinality(Prop) == 1 .
ceq props2cols(Prop) = column(name(Prop), type2type(type(Prop)), []) 
   if cardinality(Prop) == 0 .
eq props2cols(Props) = props2cols(head(Props)) props2cols(tail(Props)) .
\end{verbatim}
A property with cardinality greater than one has to be mapped int a table not a column, thus we have a special mapping function for collections.

\subsubsection{Mapping of Collections}
A property collection is mapped into a table which contains a foreign key. The key references the table representing the owning class.
\begin{verbatim}
op collections2tables : Qid List{Property} -> List{Table} .
op collections2tables : Qid Property -> Table . 

eq collections2tables(Q, []) = ([]).List{Table} .
eq collections2tables(Q, Prop) = table(name(Prop), primaryKey('Id), 
   column('value, type2type(type(Prop)), [] ), foreignKey(Q, Q, NOTNULL)) .
eq collections2tables(Q, Props) = collections2tables(Q, head(Props)) 
   collections2tables(Q, tail(Props)) .
\end{verbatim}

\subsection{Mapping of Associations}
A association is mapped into database as a foreign key in table representing associating class or an association can be mapped as a coupling table in case the association cardinality is M:N or 1:N . 
\begin{verbatim}
op associations2db : Qid List{Association} Database -> Database .
op associations2db : Qid Association Database -> Database .
	
eq associations2db(Q, [], D) = D .
eq associations2db(Q, Assoc, EDb) = EDb .
ceq associations2db(Q, Assoc, D) = addFK(foreignKey(name(Assoc), Q, NOTNULL), 
	   referenceA(Assoc), D) if startCardinality(Assoc) < 2 . 
eq associations2db(Q, Assoc, D) = addTable(table(name(Assoc), 
   primaryKey('Id'), [], 
   foreignKey(Q, Q, NOTNULL) 
   foreignKey(name(Assoc), name(Assoc), NOTNULL)), D) .
	eq associations2db(Q, Assoc, D) = associations2db(Q, tail(Assoc), 
   associations2db(Q, head(Assoc), D)) .
\end{verbatim}



	



\end{document}
