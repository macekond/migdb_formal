\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{semantic}
\usepackage{listings}
\usepackage{hyperref}

\begin{document}
\tableofcontents

\newpage
\section{Evolution of ORM System}
The ORM system consist of application and database. The application and database has to be in consistent state according to a concrete ORM algorithm, otherwise the application cannot work properly. It means that during the evolution we have to respect a concrete ORM to produce consistent result.
$$
OrmSystem = (Application, Database)
$$
%TODO define consistency

There are several way how the evolution of ORM system can be implemented. The way when the application is evolved, database scheme re-genareted by an ORM framework and data migrated manually is the most common nowadays. The goal of our project is to minimize the manual work in the process of data evolution. We have following options:
\begin{itemize}
	\item Backward round-trip engineering can be used. It means the application and database is evolved and then the difference in structure is used to define data migration. This approach is inappropriate for situations where there is stored data as a change in database schema can be connected with more possible changes of data. Hence an additional information from user will be needed to migrate data correctly.
    \item Forward engineering can be used in two ways. First approach evolves application, re-generate a database schema and generate a data migration according to definition of application evolution. Second approach uses the definition of application evolution as a source for evolution of database schema and data migration. In contrast this approach preserves the original database - it only alters its structure, whereas the first approach creates a new database.
\end{itemize}
All approaches can be used and all of them have their pros and cons. We decide to use forward engineering approach as it is a natural way of evolution. Next we decide to generate both migrations (for database schema and data) from definition of application evolution. This allows us to keep history of all layers and to verify the evolution on multiple levels. The algorithm is illustrated in Figure \ref{fig:algorithm}.

The figure shows all important components of the domain. There are three static components (static because they do not define behavior, but state of the system): an application, a database schema and stored data. Then there are four dynamic components (they define transformations between components and transition between system states): an object-relational mapping is a transformation between application and database schema, then are two components for evolution of application and of database. (To simplify the model we will consider the database schema and data are evolved by one component). Last component is the most important one - it is component which maps the evolution from application level to relational database level. We call this component evolution object-relational mapping (eORM).
 

There is a description of each component following. The description defines set of models of static components and dynamic components are defined as functions. There are several common parts of the model we can define in advance. The model uses a set $Labels$ which contains all possible identifiers for the model. Each model component which has a label ($label \in Labels$) is unambiguously identified in the model.

%%%%%%%%%%%%%%%%%%%

\section{Application Component}
The application component represent an application created using object oriented language. It means the application is a set of instances which cooperates together. Each instance is defined according to a class - the class defines the structure and relationships of the instance. 
The application component model consists of  classes defining the structure of application:
 
$$
Application = (Class*)
$$
$classes : Application \rightarrow Class*$ \\
$classes((classes)) = classes$



\subsection{Application Structure Definition}
The structure of the application is defined by five concepts. Each concept is defined and a set of manipulating functions is define to manipulate the application model easily.

\paragraph{Class} represents a basic structural concept in the application model. It has a unique name, one or more properties and a class can be associated to other classes in the application. 
	 
$$Class = (label, Property*, Association*)$$
$name : Class \rightarrow Label$ \\
$name((lab, props, assocs)) = lab$ \\ \\
$properties : Class \rightarrow Property*$ \\
$properties((lab, props, assocs)) = props $\\ \\
$primitiveProperties : Class \rightarrow Property*$ \\
$primitiveProperties((lab, props, assocs)) = props', \forall p \in props' : cardinality(p) \leq 1 $\\ \\
$collectionProperties : Class \rightarrow Property*$ \\
$collectionProperties((lab, props, assocs)) = props', \forall p \in props' : cardinality(p) > 1 $\\ \\
$associations : Class \rightarrow Association*$ \\
$associations((lab, props, assocs)) = assocs $


\paragraph{Property} represents a feature of  a class which is can be represented as a primitive type. The property can be mandatory, can have a default value.
$$
Property = (label, AppType, DefaultValue, Cardinality)
$$
$name : Property \rightarrow Label$ \\
$name((lab, t, val, n)) = lab$ \\ \\
$type : Property \times AppType$ \\
$type((lab, t, val, n)) = t$ \\ \\
$cardinality : Property \rightarrow NzNat$ \\
$cardinality((lab, t, val, n)) = n$ \\ \\
$owningClass : Property \times Application \rightarrow Class $ \\
$owningClass(p, a) = c, c \in classes(a) \wedge p \in properties(c) $


\paragraph {Association} represents a connection between two classes. It has a unique name and it contains a name of the class which is referenced by the association. The class which owns the association is consider to be a starting class of an association, referenced class is consider to be an ending class of an association. The cardinalities defines the multiplicity of the association.
$$
Association = (label, classRef, startCardinality, endCardinality)
$$
$name : Association \rightarrow Label$ \\
$name((lab, ref, n_1, n_2)) = lab$\\ \\
$reference : Association \rightarrow Label$ \\
$reference((lab, ref, n_1, n_2)) = ref$\\ \\
$startCardinality : Association \rightarrow NzNat$ \\
$startCardinality((lab, ref, n_1, n_2)) = n_1$\\ \\
$endCardinality : Association \rightarrow NzNat$ \\
$endCardinality((lab, ref, n_1, n_2)) = n_2$ \\ \\
$owningClass : Association \times Application \rightarrow Class $ \\
$owningClass(as, a) = c, c \in classes(a) \wedge as \in associations(c) $

\paragraph{AppType} represents primitive types in the application. There are usually defined types such as String, Integer, Boolean etc. in contrast there is only one type in our model, because we focus on structural and data changes and type casting operations are not important for us. The only App-Type type is called APP-STRING.
$$
AppType = APPSTRING
$$
The types used in application model:
$$
cardinality = NzNat
$$
$$
referencesClass = label
$$
$$
startCardinality = NzNat
$$
$$
endCardinality = NzNat
$$
$$
NzNat = [0 - 9]*
$$




\section{Application Evolution}
\label{sec:appEvolution}

The evolution is defined as a set of operations which change structure of an application. The definition of an operation consists of two parts - a conditions of operation feasibility and operation impact on the application structure. We decide to use following transcription:

$$
operation = \inference{conditions$ $of$ $feasibility}{impact$ $on$ $application$ $structure}
$$
If the conditions of feasibility are not met, the operation cannot impact the application structure.
%TODO monade


\subsection{Application Creation}
$$AddClass: Class \times Application \rightarrow Application $$

$
AddClass(c, a) = \inference{\forall s \in classes(A) : name(s) \neq name(c)}
{classes(a) \cup c}
$

$$AddProperty : Label \times Property \times Application \rightarrow Application $$

$
AddProperty(l, p, a) = \inference{\exists c \in classes(a) : name(c) = l \\ \wedge \not \exist q \in properties(p) : name(q) \neq name(p)}{
 properties(c) \cup p }
$
$$AddAssociation : Label \times Association \times Application \rightarrow Application $$
$
AddAssociation(l, s, a) = \inference{\not \exists f \in associations(a) : name(f) = name(s) \\ \wedge \exists c in classes(a) : name(c) = l \\ \wedge \exists k \in classes(a) : name(k) = reference(s) }{associations(a) \cup s}
$

\subsection{Application Deconstruction}
$$RemoveClass: Label \times Application \rightarrow Application $$
$
RemoveClass(q, a) = \inference{\exists c \in classes(a) : name(c) = q \\
\wedge not$ $instantiated(c) = \{ \} \wedge not$ $associated(c)}{classes(a) \setminus c }
$

$$RemoveProperty: Label \times Label \times Application \rightarrow Application $$

$
RemoveProperty(l_c, l_p, a) = \inference{\exists c \in classes(a) : name(c) = l_c \\ \wedge \exists p \in properties(c) : name(p) = l_p}{properties(c) \setminus p }
$

$$RemoveAssociation : Label \times Labels \times Application \rightarrow Application $$

$
RemoveAssociation(l_c, l_a, a) = \inference{\exists c \in classes(a) : name(c) = l_c \\ \wedge \exists s \in associations(c) : name(s) = l_a }{associations(c) \setminus s}
$

%%%%%%%%%%%%%%%%%%%

\section{Database model}
The relational database consists of database schema which defines the structure of the database and data. The database is a pair od sets:
$$
Database = (table*, data*)
$$

\subsection{Database Schema Model}
The database schema model is defined by following concepts:
\begin{itemize}
	\item Table: table represents a basic concept of database schema. It has a unique name, one or more column and it can be related to other tables in the schema by foreign keys. Rows in the table represents stored data.
$$
Table = (label, primaryKey, Column*, ForeignKey*)
$$
	\item Column : columns define possible data values and types which can be part of a table record.
$$
Column = (label, Db-Type, Constraint*)
$$

	\item Foreign key:
$$
ForeignKey = (label, tableRef, Constraint*)
$$

	\item Primary key:
$$
PrimaryKey =  (label) 	
$$

	\item Db-Type: represents primitive types in the database. There are usually defined types such as Char, Integer, Boolean etc. There is only one type defined in the model which is called DB-STRING.
$$
Db-Type = DBSTRING
$$

	\item Constraint: there are two types of constraints defined in the model. Both constraints are column constraints - first constraint defines unique records in a column, second constraint defines non-empty columns.
$$
Constraint = NOTNULL | UNIQUE 
$$
\end{itemize}

\section{Object-Relational Mapping}
There are defined functions for object-relational mapping used in the model. The purpose of a function is indicated in its name and should be obvious from its definition. These functions do not serve for full object-relational mapping, their purpose is to help with data evolution and its propagation from application to database.


\subsection{Mapping of Types}
The mapping of types assumes a bijection between application types and database types, otherwise these has to be additional information for type mapping. We focus on structural and data change therefore we simplify types and its mapping.
$$
\rho : AppType \rightarrow DbType
$$

$$
\rho(APPSTRING) = DBSTRING
$$


\subsection{Mapping of Classes}
We assume the primary key column is created automatically by database, therefore the primary key is always created with name Id and od NzNat type and properties with cardinality 0 or 1 are mapped into columns. The associations are ignored int this mapping as it is one of the partial mapping function used in eORM.

$$
\rho : Class \rightarrow Table
$$

$$
\rho(c) = table(name(c), primaryKey("Id"), \rho(properties(c), \{ \})
$$

\subsection{Mapping of Properties}
There are two types of properties - the first type has cardinality 0 or 1 and it is mapped to a column (when the cardinality is equal to 1 the $NOTNULL$ constraint is added to a column). A property with cardinality greater than one has to be mapped int a table not a column, thus we have a special mapping case.


%TODO split \rho function?

$
\rho : Property \times Database \rightarrow Column 
$

$\rho(p, d) = \begin{cases}
 \inference{cardinality(p) = 0 \\ \wedge \rho(owningClass(p) \in classes(d)}{columns(owninngClass(p)) \cup column(name(p), \rho(type(p)), \{ \})} \\ \\
 
 \inference{cardinality(p) = 1 \\ \wedge \rho(owningClass(p) \in classes(d)}{columns(owninngClass(p)) \cup col(name(p), \rho(type(p)), NOTNULL)} \\ \\
 
 \inference{cardinality(p) > 2 \\ \wedge \rho(owningClass(p) \in classes(d)}{\begin{gathered} tables(d) \cup table(name(p), pk("Id"), col("value", DBSTRING), \\ fk(name(p), \rho(owningClass(p))) \end{gathered}}
 \end{cases}$


\subsection{Mapping of Associations}
A association is mapped into database as a foreign key in table representing associating class or an association can be mapped as a coupling table in case the association cardinality is M:N or 1:N.

$
\rho(a,d) = \begin{cases}
 \inference{startCardinality(a) = 0 \\ \wedge \rho(owningClass(p) \in classes(d)  \wedge \rho(reference(a)) \in tables(d)}{foreignKeys(\rho(assoc(a)) \cup foreignKey(name(a), owningClass(a),  \{ \}) } \\ \\
 
 \inference{startCardinality(a) = 1 \\ \wedge \rho(owningClass(p) \in tables(d)  \wedge \rho(reference(a)) \in tables(d)}{\begin{gathered}
 foreignKeys(\rho(assoc(a)) \cup foreignKey(name(a), \\ owningClass(a),  NOTNULL)
\end{gathered}
} \\ \\
 
  \inference{startCardinality > 1 \\ \wedge \rho(owningClass(p)) \in tables(d) \wedge \rho(reference(a)) \in tables(d)}{
  \begin{gathered}
  tables(d) \cup table(name(a), pk("Id"), \{ \}, \\ foreignKey(owningClass(a),owningClass(a), NOTNULL) \\ foreignkey(reference(a), reference(a), NOTNULL)) 
  \end{gathered}}

  
 \end{cases}
$

%TODO FK nemusí mít jméno - odkazuje jen na tabulku a id

\section{Data Evolution in ORM System}
The Object-Relational system consist of an application and a database. The system has to be in consistent state, therefore the evolution of application has to be propagated correctly into database. Each evolution operation consist of two parts - applying evolution operation on application and on database. In general an evolutionary operation $X : OrmSystem \rightarrow OrmSystem $ can be defined as:

$$
\inference[X(s) = ]{}{system(X(application(s)), \rho_{X}(database(s))) }
$$
where the $\rho_X$ is the mapping of the evolution from application to database. The mapping of the evolution change is called extended Object-Relational Mapping (eORM). The eORM mapping helps to assure consistency of the system by transforming application evolution into database schema and data. Each eORM function applied on an ORM system produces a new generation of the system. If the function cannot be applied on a system the system cannot be evolved by the function. 

This section defines eORM for each trivial operation evolving application from \ref{sec:appEvolution}, moreover there are described more complex cases of evolution. 
 

\subsection{Creating of a System}
Creational operations does not have impact on stored data they change the structure of the application and database by adding new objects into model.

\subsubsection{Add Class}

$
\rho_{addClass}(c, d) = \inference{\forall t \in tables(d) : name(t) \neq name(\rho(c)) \\
	\forall a \in \rho(associations(c)) : reference(a) \in tables(d) 
}{ %TODO podmínky?
\begin{gathered}
tables(d) \cup \rho(c) \cup \rho(properties(c)) \cup \rho(associations(c))
\end{gathered}
}
$
\subsubsection{Add Property}
$
\rho_{addProperty}(l, p, d) = 
\inference{\exists t \in tables(d) : name(t) = l}{\rho(p,d)} 
$
\subsection{Add Association}
$
\rho_{AddAssociation}(l, a, d) = \inference{\exists t_1, t_2 \in tables(d) : name(t_1) = l \\ \wedge name(t_2) = reference(a) \\ \wedge \not \exists f \in foreignKeys(t_1) : name(f) = name(a) }{\rho(a,d)}
$


\subsection{Deconstruction of a System}
\subsubsection{Remove Class}
$
\rho_{removeClass}(c,d) = \inference{\rho(c) \in tables(d) \\ \wedge \not \exists r \in data(d) : owningTable(r) \neq \rho(c) \\ \not \exists j \in tables(d), f \in foreignKeys(j) : reference(f) = \rho(c)  }{tables(d) \setminus \rho(c)}
$
%TODO remove by label

\subsubsection{Remove Property}
$
\rho_{removeProperty}(l_c, l_p, d) = \inference{\exists t \in tables(d) : name(t) = l_c \\ \wedge \exists c \in columns(t) : name(c) = l_p  }{
columns(t) \setminus c
}
$
%TODO 1:N M:N

	



\end{document}
