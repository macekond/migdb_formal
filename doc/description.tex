\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{semantic}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{algpseudocode}


\title{Evolution of ORM Systems: Formal Foundations}
\author{Ondrej Macek}

\begin{document}

\maketitle
\begin{abstract}
The evolution of a software is a common issue during software lifecycle. The evolution od code and database are usually separated tasks. We discuss the evolution of software in context of  software created using an object oriented programming language and a relational database. The formal definition of the evolutionary framework is introduced in this paper. Special attention is given to the data stored in databases (instances) and theirs consistency during evolution process.
\end{abstract}

\textbf{Keywords:} data evolution, data migration
\section{Introduction}
The evolution of a software is a common issue during software development. The evolution can occur from many reasons in different stages of software lifecycle. The evolution of a software created using an object oriented programming language and a relational database is usually processed in two steps - as a code refactoring and as a database migration, which is processed as an SQL script. The code refactoring is supported by many IDEs, whereas the database migration is usually processed manually. There are frameworks and tools capable of database evolution, nevertheless these tools are usually not capable to solve complicated migration cases or preserve stored data. Another disadvantage of such an approach to data evolution is the evolution has to be define twice - as a code refactoring and as a database migration.

There are three main goals of our evolutionary framework: 1) provide one source of evolution definition for both: code and database 2) provide a tool, which will be able to preserve stored data 3) minimize the manual work during data evolution in a software.

This paper provides a formal definition of such a framework, which is based on model driven architecture. There are defined models representing an application and database in this paper, together with transformations which are able to perform an evolution of the whole software and preserve data.

The paper is organized as follows: in Section \ref{sec:evoIntro} the concept of ORM software and its evolution is discussed, then models of application and database are introduced in Section \ref{sec:appModel} and in Section \ref{sec:dbModel}, the ORM is defined in Section \ref{sec:orm} and the evolutionary transformations are defined in Section \ref{sec:eorm}.

\section{ORM Software}
\label{sec:evoIntro}
\begin{figure}
\centering
	\includegraphics[scale=0.3]{./images/system}
	\caption{The model of one generation of an ORM system consists of application persistent layer and relational database for storing instances.}
\label{fig:appStructure}
\end{figure}
A software implemented in an object-oriented language, which uses relational database as a data storage is context of this paper. The situation is illustrated in the Figure \ref{fig:appStructure}. There are three important components of such a software: application (its persistent layer concretely), database (consisting of database schema and stored data) and an ORM (we will use $\rho$ as a symbol for ORM), therefore we define a software a triple:
\begin{gather*}
	software = < Application, Database, \rho > \\
	soft : Applications \times Databases \times ORM \rightarrow Software \\ \\
	application : Software \rightarrow Application \\
	application(soft(a, d, \rho)) = a \\ \\
	database : Software \rightarrow Database \\
	database(soft(a, d, \rho)) = d \\
	a \in Applications, d \in Databases
\end{gather*}
The software has to be in consistent state so it is beneficial for its user. The state of the software is defined to communicate the sate of the software to its user:
\begin{gather*}
	state = Consistent\; s \: | \: Inconsistent \; s, \\
	s \in Softwares  \\ \\
	state : Software \rightarrow State \\
	state(s) = \begin{cases}
 		\inference{consistent(application(s)) \wedge \\ consistent(database(s)) \wedge \rho(application(s)) = database(s)}{Consistent \; s}\\ \\
 		\inference{otherwise}{Inconsistent \; s}
 	\end{cases}
\end{gather*}
\subsection{Software Evolution}
\begin{figure}
\centering
	\includegraphics[scale=0.4]{./images/evolution_simple}
	\caption{The evolution of data changes the system on all levels. The figure shows all the components of the evolution process.}
	\label{fig:evolution}
\end{figure}
The evolution of a software is a transformation from one consistent state to another one. These states are called generations of the software. The evolution consists of change in application and in database as shown in the Figure \ref{fig:evolution}. We focus on situations when the evolution is initiated on the application level (as code refactoring), however the evolution has to be processed on the database level too. It means there is a set of application transformations called $AppOps$ and a set of database transformations called $DbOps$. Because there are needed different parameters for application and database evolution the set of transformation called $E$ which evolves the whole software and a mapping between $E$ and $AppOps$, respectively $DbOps$ is defined. We call this mappings $\Psi$ and $\Phi$:
\begin{gather*}
\Psi : E \rightarrow AppOps \\
\Phi : E \rightarrow DbOps
\end{gather*}
A subset of $E$ represents an evolution transformation of a software, which mets the first goal of our framework - a single source of data evolution for the whole software.

The application of a transformation on a software state (evolution) is marked by the $\oplus$ operator:
$$\oplus : State \times E \rightarrow State $$
and similarly the $\circ$ and the $\bullet$ operators for evolving application and database:
\begin{gather*}
\circ : Application \times AppOps \rightarrow Application \\
 \bullet : Database \times DbOps \rightarrow Database
\end{gather*}
The definition of the evolving operator is inspired by the monads (as used e.g. in Haskell programming language) so the state of the software can be passed from one evolution step to another, which helps us to concatenate evolution transformations.

\begin{gather*}
 u \oplus t = \begin{cases}
 	\inference{u = Inconsistent \; s}{u} \\ \\
 	\inference{u = Consistent \; s}{state(soft(application(u) \circ \Psi(t), database(u) \bullet \Phi(t))} 
\end{cases}\\ 
u \in States, t \in E, s \in Softwares
\end{gather*}
\begin{gather*}
 a \circ o = \begin{cases}
 	\inference{!\;consistent(a)}{a} \\ \\
 	\inference{consistent(a)}{a \circ o} 
\end{cases}\\ 
a \in Applications, o \in AppOps
\end{gather*}
\begin{gather*}
 d \bullet o = \begin{cases}
 	\inference{!\;consistent(d)}{d} \\ \\
 	\inference{consistent(d)}{d \circ o} 
\end{cases}\\ 
d \in Applications, o \in DbOps
\end{gather*}

\section{Software Model}
The model of an ORM software consists of three parts - an application model, a database model and a ORM. 

\subsection{Application Model}
\label{sec:appModel}
The model represents a persistent layer of an application created using object oriented language. It means the layer is a set of instances which cooperates together. Each instance is defined according to a class - the class defines the structure and relationships of the instance. The instances are stored in the relational database in our case, therefore we define only the structure of classes in our model. 

The model uses a set $Labels$ which contains all possible identifiers for the model. Each model component which has a label ($label \in Labels$) is unambiguously identified in the model.
\begin{gather*}
  Application = < Class* >
  \\ 
  app : Class* \rightarrow  Application \\ \\
  classes : Application \rightarrow Class* \\
  classes(app(cs)) = cs  \\\\
  class : Label \times Application \rightarrow Class   \\ 
  class(l, a) = c, c \in classes(a) \wedge name(c) = l \\ \\
  l \in Label, a = Application, cs \in Class* 
  \\ \\
  associated :  Label \times Application \rightarrow Boolean \\
  owningClass : Property \times Application \rightarrow Class  \\ owningClass(p, a) = c, c \in classes(a) \wedge p \in properties(c) \\
  owningClass : Association \times Application \rightarrow Class  \\
owningClass(as, a) = c, c \in classes(a) \wedge as \in associations(c) \\ \\
owningTable : Column \times Database \rightarrow Table  \\
owningTable(c, d) = tab, tab \in tables(d) \wedge c \in columns(d) \\ \\
owningTable : ForeignKey \times Database \rightarrow Table  \\
owningTable(fk, d) = tab, tab \in tables(d) \wedge fk \in foreignKeys(d)\\ \\ 
\end{gather*}
The structure of an application consists not only of classes, it is defined by five other concepts. Besides the structure definition, there is defined a set of functions, which allows to manipulate the application model easily. 

\paragraph{Class} represents a basic structural concept in the application model. It has a unique name, one or more properties and a class can be associated to other classes in the application. 

$$Class = <label, Property*, Association*>$$
\begin{equation*}
\begin{alignat}{2}
cl : Label \times Property* \times Association* \rightarrow Class &\quad&\text{constructor}\\ \\
% TODO association has to be only to self (all associated has to exists)
name : Class \rightarrow Label &\quad&\text{name of the class}\\
name(cl(l, props, assocs)) = l \\ \\
properties : Class \rightarrow Property* &\quad&\text{all properties}\\
properties(cl(l, props, assocs)) = props \\ \\
primitiveProperties : Class \rightarrow Property* &\quad&\text{all primitive properties}\\
primitiveProperties(cl(l, props, assocs)) = props', \\ props' \subset props,  \forall p \in props' : cardinality(p) \leq 1 \\ \\
collectionProperties : Class \rightarrow Property* &\quad&\text{all collections}\\
collectionProperties(cl(l, props, assocs)) = props', \\ props' \subset props, \forall p \in props' : cardinality(p) > 1 \\ \\
associations : Class \rightarrow Association* &\quad&\text{all associations}\\
associations(cl(l, props, assocs)) = assocs
\end{alignat}
\end{equation*}
$$l \in Label, props \in Properties, assocs \in Associations$$
	 

\paragraph{Property} represents a feature of  a class which is can be represented as a primitive type. The property can be mandatory, can have a default value.
\begin{gather*}
Property = <label, AppType, DefaultValue, Cardinality, Mandatory> \\ \\
prop : Label \times AppType \times String \times \mathbb{N^{*}} \times Boolean \rightarrow Property \\ \\
name : Property \rightarrow Label \\
name(prop(l, t, val, n, m)) = l \\ \\
type : Property \times AppType \\
type(prop(l, t, val, n, m)) = t \\ \\
cardinality : Property \rightarrow \mathbb{N^{*}} \\
cardinality(prop(l, t, val, n, m)) = n \\ \\
mandatory : Property \rightarrow Boolean \\
mandatory(prop(l, t, val, n, m)) = m  \\ \\
l \in Label, t \in AppType, val \in String*, n \in \mathbb{N^{*}}, m \in Boolean
\end{gather*}


%TODO: variable types

\paragraph {Association} represents a connection between two classes. It has a unique name and it contains a name of the class which is referenced by the association. The class which owns the association is consider to be a starting class of an association, referenced class is consider to be an ending class of an association. The cardinalities defines the multiplicity of the association.
\begin{gather*}
Association = <label, classRef, startCardinality, endCardinality> \\ \\
assoc : Label \times Label \times \mathbb{N} \times \mathbb{N} \rightarrow Association
name : Association \rightarrow Label \\
name(assoc(l, ref, n_1, n_2)) = l\\ \\
reference : Association \rightarrow Label \\
reference(assoc(l, ref, n_1, n_2)) = ref\\ \\
startCardinality : Association \rightarrow \mathbb{N} \\
startCardinality(assoc(l, ref, n_1, n_2)) = n_1\\ \\
endCardinality : Association \rightarrow \mathbb{N} \\
endCardinality(assoc(l, ref, n_1, n_2)) = n_2 \\ \\
l, ref \in Label,  n_1, n_2 \in \mathbb{N}
\end{gather*}


%TODO: variable types

\paragraph{AppType} represents primitive types in the application. There are usually defined types such as String, Integer, Boolean etc. in contrast there is only one type in our model, because we focus on structural and data changes and type casting operations are not important for us. The only App-Type type is called APP-STRING.
$$
AppType = APPSTRING
$$

\subsection{Database Model}
\label{sec:dbModel}
The relational database consists of database schema which defines the structure of the database and data, which in our ORM system represents instances. The database is:
\begin{gather*}
Database = <table*, row*> \\ \\
db : Tables \times Rows \rightarrow Database \\ \\
tables : Database \rightarrow Tables \\
tables(db(tabs, rows)) = tabs \\ \\
data : Database \rightarrow Rows \\
data(db(tabs, rows)) = rows \\ \\
table : Label \times Database \rightarrow Table  \\
table(l, d) = t, t \in tables(d) \wedge name(t) = l \\ \\
tabs \in Tables, rows \in Rows, l \in Labels, d \in Databases
\end{gather*}


\subsubsection{Database Schema Model}
The database schema model is defined by following concepts:
\paragraph{Table} represents a basic concept of database schema. It has a unique name, one or more column and it can be related to other tables in the schema by foreign keys. Rows in the table represents stored data.
\begin{gather*}
Table = <label, primaryKey, Column*, ForeignKey*>\\ \\
tab : Label \times PrimaryKeys \times Columns \times ForeignKeys \rightarrow Table \\ \\
name : Table \rightarrow Label  \\
name(tab(l, pk, cols, fks)) = l \\ \\
primaryKey : Table \rightarrow PrimaryKeys  \\
primaryKey(tab(l, pk, cols, fks)) = pk \\ \\
columns : Table \rightarrow Columns  \\
columns(tab(l, pk, cols, fks)) = cols \\ \\
foreignKeys : Table \rightarrow ForeignKeys  \\
foreignKeys(tab(l, pk, cols, fks)) = fks \\ \\
l \in Label, pk \in PrimaryKey, cols \in Columns, fks \in ForeignKeys
\end{gather*}

\paragraph{Column} columns define possible data values and types which can be part of a table record.
\begin{gather*}
Column = <label, DbType, DefaultValue, Constraint*> \\ \\
col : Label \times DbType \times String \times Constraints \rightarrow Column \\ \\
name : Column \rightarrow Label  \\
name(col(l, t, val, cons)) = l  \\ \\
type : Column \rightarrow DbType  \\
type(col(l, t, val, cons)) = t  \\ \\
constraints : Column \rightarrow Constraints  \\
constraints(col(l, t, val, cons)) = cons  \\ \\
l \in Labels, t \in DbType, val \in Strings, cons \in Constraints
\end{gather*}

\paragraph{Foreign key}
\begin{gather*}
ForeignKey = <label, tableRef, Constraint*> \\ \\
fk : Label \times Label \times Constraints \rightarrow ForeignKey \\ \\
name : ForeignKey \rightarrow Label \\
name(fk(l, tRef, cons)) = lab  \\ \\
reference : ForeignKey \rightarrow Label  \\
reference(fk(l, tRef, cons)) = tRef  \\ \\
reference : ForeignKey \rightarrow Constraint*  \\
reference(fk(l, tRef, cons)) = cons  \\ \\
l, tRef \in Label, cons \in Constraints
\end{gather*}


\paragraph{Primary key}
\begin{gather*}
PrimaryKey =  < label > 	\\
pk : Label \rightarrow PrimaryKey
\end{gather*}

\paragraph{DbType} represents primitive types in the database. There are usually defined types such as Char, Integer, Boolean etc. There is only one type defined in the model which is called DBSTRING.
$$
DbType = DBSTRING
$$

\paragraph{Constraint} there are two types of constraints defined in the model. Both constraints are column constraints - first constraint defines unique records in a column, second constraint defines non-empty columns.
\begin{gather*}
Constraint = NOTNULL \; | \; UNIQUE 
\end{gather*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Model of Stored Data}
A database consists not only from schema but also from data which are represented as rows in a table. A table row in our model is a tuple consisting of reference to a concrete table and a set of value pairs, which represents concrete values of concrete columns.
\begin{gather*}
row = < refTable, pair* > \\
row : Label \times Pairs \rightarrow Row \\ \\
refTable : Row \rightarrow Label \\
refTable(row(l, pairs) = l \\ \\
contains : Table \times Database \rightarrow Boolean \\
contains(t, d) = \begin{cases}
 \inference{\exists r \in data(d) : refTable(r) = name(t) }{true} \\ \\
  \inference{\forall r \in data(d) : refTable(r) \neq name(t)}{false}
 \end{cases} \\ \\
 l \in Labels, pairs \in Pairs, t \in tables(d), d \in Database
\end{gather*}
There functions $contains$ verify if the table contains any data.

\begin{gather*}
pair = < refCol, value > \\
[Label \times Strings] \rightarrow Pair
\end{gather*}
The $reference $ is a name of a column, a foreign key or its primary key and $value$ represents concrete value stored in the database. Each row in a database has to refer to a table in database schema, otherwise the database is inconsistent. The consistency of database is then:
\begin{equation*}\begin{gathered}\forall r \in data(d), \exists t \in tables(d) : reference(r) = name(t) \\ \wedge \forall p \in pairs(r) \exists u \in columns(t) \cup foreignKeys(t) : reference(p) = name(u) \end{gathered}\end{equation*}

second of them verify if there are instances of a class:
$$instantiated : Class \times Software \rightarrow Boolean $$ 
\begin{equation*}
\begin{gathered}
	instantiated(c, s) = \begin{cases}
 \inference{\exists t \in tables(database(s)) : name(t) = name(c) \\ \wedge contains(t, database(s))}{true} \\ \\
  \inference{\exists t \in tables(database(s)) : name(t) = name(c) \\ \wedge ! contains(t, database(s))}{false} \\ \\
 \end{cases} \\ \\
 c \in classes(application(s)), s \in Software 
\end{gathered}
\end{equation*}

\subsection{Object-Relational Mapping}
\label{sec:orm}
There are defined functions for object-relational mapping used in the model in this section. The purpose of a function is indicated by its name and should be obvious from its definition. These functions do not serve for full object-relational mapping, their purpose is to help with data evolution (see Section \ref{sec:eorm}) and its propagation from application to database. However the database can be obtained from an application model by using following algorithm:

\begin{algorithmic}[1]
	\Require $a \in Application$
	\State d = Database
	\ForAll{$c \in classes(a)$} 
		\State $\rho_c(c), d$
		\ForAll{$p \in properties(c)$} 
			\State $\rho_p(p, d)$
		\EndFor
	 \EndFor
	\ForAll{$c \in classes(a)$}
		\ForAll{$as \in associations(c)$} 
			\State $\rho_{a}(as, d)$
		\EndFor
	\EndFor
\end{algorithmic}


\subsubsection{Mapping of Types}
The mapping of types assumes a bijection between application types and database types, otherwise these has to be additional information for type mapping. We focus on structural and data change therefore we simplify types and its mapping.

\begin{equation*}
\begin{gathered}
	\rho_{t} : AppType \rightarrow DbType  \\
 	\rho_{t}(APPSTRING) = DBSTRING 
\end{gathered}
\end{equation*}

\subsection{Mapping of Classes}
We assume the primary key column is created automatically by database, therefore the primary key is always created with name Id and of the $\mathbb{N^{*}}$ type and properties with cardinality 0 or 1 are mapped into columns. The associations are ignored int this mapping as it is one of the partial mapping function used in eORM.

\begin{center}
$\rho_{c}: Class \rightarrow Table $ \\ 
$\rho_{c}(c,d) = tables(d) \cup table(name(c), primaryKey("Id"), \varnothing, \varnothing) $
\end{center}

\subsubsection{Mapping of Properties}
There are two types of properties - the first type has cardinality 1  and it is mapped to a column. A property with cardinality greater than one has to be mapped int a table not a column, thus we have a special mapping case. When the property is mandatory the $NOTNULL$ constraint is added to the column with property value. This constraint affect already stored instances a new mandatory value has to be added to each instance.

$
\rho_p : Property \times Database \rightarrow Column 
$

$\rho_p(p, d) = \begin{cases}
  \inference{cardinality(p) = 1 \wedge ! mandatory(p)
 \\ \wedge \exists t : t = table(name(owningClass(p)), d) 
 \\ \wedge \not instanciated(owningClass(p))
 }{\begin{gathered}
	  columns(t) \cup column(name(p), \rho_t(type(p)), \varnothing )
\end{gathered}
 } \\ \\

  \inference{cardinality(p) = 1 \wedge mandatory(p)
 \\ \wedge \exists t : t = table(name(owningClass(p)), d)}{\begin{gathered}
 	 columns(t) \cup column(name(p), \rho_t(type(p)), NOTNULL ) \\ 
\end{gathered}} 
\\ \\
 
 \inference{ cardinality(p) > 1 \wedge ! mandatory(p) \\ \wedge \exists t : t = table(name(owningClass(p)), d)}{\begin{gathered}tables(d) \cup  table(name(p), primaryKey("Id"), \\ column("value", \rho_t(type(p)), \varnothing), \\ foreignKey(name(p), name(owningClass(p)), NOTNULL) \\
\end{gathered}}
\\ \\

 \inference{ cardinality(p) > 1 \wedge mandatory(p) \\ \wedge \exists t : t = table(name(owningClass(p)), d) }{\begin{gathered} tables(d) \cup  table(name(p), primaryKey("Id"), \\ column("value", \rho_t(type(p)), NOTNULL), \\ foreignKey(name(p), name(owningClass(p)), NOTNULL)
	 \end{gathered}}
 \end{cases}$

\subsubsection{Mapping of Associations}
A association is mapped into database as a foreign key in table representing associating class or an association can be mapped as a coupling table in case the association cardinality is M:N or 1:N.

$
\rho_a(a,d) = \begin{cases}
 \inference{ startCardinality(a) = 0 \\ \wedge \exists t : t = table(name(owningClass(p)), d) \\ \wedge \exists u : u = table(reference(a)), d)}{ 
 \begin{gathered}
 foreignKeys(u) \\ \cup foreignKey(name(a), name(t),  \varnothing) 
 \end{gathered}
 }
  \\ \\
 \inference{ startCardinality(a) = 1 \\ \wedge \exists t : t = table(name(owningClass(p)), d) \\ \wedge \exists u : u = table(reference(a)), d)}{\begin{gathered}  
foreignKeys(u) \\ \cup  foreignKey(name(a), name(t),  NOTNULL) \\
\end{gathered}
} \\ \\
 
  \inference{  startCardinality > 1 \\ \wedge \rho(owningClass(p)) \in tables(d) \wedge \rho(reference(a)) \in tables(d)}{
  \begin{gathered}  
 table(name(a), pk("Id"), \varnothing, \\ foreignKey(owningClass(a),owningClass(a), NOTNULL) \\ foreignkey(reference(a), reference(a), NOTNULL)) 
  \end{gathered}}  
 \end{cases}
$

\section{Evolutionaty Transformations}
Each evolutionary transformation of a software consist in changes of the application (a transformation from the $AppOps$ set) and the database (a transformation from the  $DbOps$ set). The function $\Phi$ provides a mapping between the $AppOps$ and $DbOps$ sets, which makes the $AppOps$ set a source for the transformation of the whole software.

The definition of a transformation consists of two parts - a conditions of transformation feasibility and its impact on the context. If the conditions of feasibility are not met, the transformation cannot change the context - the software cannot evolve.  We decide to use following transcription to cover all aspects  of transformation definition:
\begin{gather*}
operation(parameters, context) = \begin{cases}
  \inference{conditions \; of \; feasibility}{impact \; on \; context}\\ \\
  \inference{otherwise}{context}
 \end{cases}
\end{gather*}

The second branch of the operation definition is an implicit assumption - if an operation is not feasible in a software, its state become inconsistent. We will not state this implicit assumption in the operations definitions to increase theirs readability.


\subsection{Application Transformation}
\subsubsection{Application Creation}
\begin{gather*}
addClass: Class \times Application \rightarrow Application \\ 
addClass(c, a) = \inference{\forall s \in classes(a) : name(s) \neq name(c)}{classes(a) \cup c} \\ \\
c \in Classes, a \in Applications
\end{gather*}
\begin{gather*}
AddProperty : Label \times Property \times Application \rightarrow Application \\
AddProperty(l, p, a) = \inference{\exists c \in classes(a) : name(c) = l \\ \wedge \forall q \in  properties(p) : name(q) \neq name(p)}{properties(c) \cup p } \\
l \in Label, p \in Properties, a \in Applications
\end{gather*}
\begin{gather*}
AddAssociation : Label \times Association \times Application \rightarrow Application \\
AddAssociation(l, s, a) = \inference{\forall f \in associations(a) : name(f) \neq name(s) \\ \wedge \exists c \in classes(a) : name(c) = l \\ \wedge \exists k \in classes(a) : name(k) = reference(s) }{associations(c) \cup s}\\
l \in Labels, s \in Associations, a \in Applications
\end{gather*}

\subsubsection{Application Deconstruction}
\begin{gather*}
RemoveClass: Label \times Application \rightarrow Application  \\
RemoveClass(q, a) = \inference{\exists c \in classes(a) : name(c) = q \\
\wedge !\: instantiated(c) = \varnothing \wedge ! \: associated(c)} {classes(a) \setminus c } \\
q \in Label, a \in Applications
\end{gather*}
\begin{gather*}
RemoveProperty: Label \times Label \times Application \rightarrow Application \\
RemoveProperty(l_c, l_p, a) = \inference{\exists c \in classes(a) : name(c) = l_c \\ \wedge \exists p \in properties(c) : name(p) = l_p}{properties(c) \setminus p }\\
l_c, l_p \in Label, a \in Applications 
\end{gather*}
\begin{gather*}
RemoveAssociation : Label \times Labels \times Application \rightarrow Application \\ 
RemoveAssociation(l_c, l_a, a) = \inference{\exists c \in classes(a) : name(c) = l_c \\ \wedge \exists s \in associations(c) : name(s) = l_a }{associations(c) \setminus s} \\
l_c, l_a \in Labels, a \in Applications
\end{gather*}


\subsubsection{Application Alternation}
\paragraph{Rename Class}
\begin{gather*}
\rho_{RenC} : Label \times Label \times Application \rightarrow Application \\ 
\rho_{RenC}(l_o, l_n, a) = \inference{\exists c \in classes(a) : name(c) = l_c \\ \wedge \forall e \in classes(a) : name(e) \neq l_n}{\begin{gathered}
c.name = l_n \wedge \forall f \in associations(e), \\ e \in classes(a), reference(f) = l_c : f.reference = l_n 
\end{gathered}}\\
l_o, l_n \in Label, a \in Applications
\end{gather*}

\paragraph{Rename Property}
\begin{gather*}
\rho_{RenP} : Label \times Label \times Label \times Application \rightarrow Application \\ \\
	\rho_{RenP}(l_c, l_o, l_n, a) = \inference{\exists c \in classes(a) : name(c) = l_c \\ \wedge \exists p \in properties(c) : name(p) = l_o \\ \wedge \forall e \in properties(c) : name(e) \neq l_n}{\begin{gathered}
p.name = l_n 
\end{gathered}}\\
l_c, l_o, l_n \in Label, a \in Applications
\end{gather*}

\paragraph{Rename Association}
\begin{gather*}
\rho_{RenA} : Label \times Label \times Label \times Application \rightarrow Application \\
	\rho_{RenP}(l_c, l_o, l_n, a) = \inference{\exists c \in classes(a) : name(c) = l_c \\ \wedge \exists a \in associations(c) : name(a) = l_o \\ \wedge \forall e \in associations(c) : name(e) \neq l_n}{\begin{gathered}
a.name = l_n 
\end{gathered}}\\
l_c, l_o, l_n \in Label, a \in Applications
\end{gather*}


\subsection{Database Transformation}
\paragraph{Add Class} The $AddClass$ operation changes the structure of the database schema only.
$$
\Phi_{AC}(c, d) = \inference{ \forall t \in tables(d) : name(t) \neq name(\rho(c)) \\
	\forall a \in associations(c), \exists u \in  tables(d) : reference(a) = name(u) 
}{
\begin{gathered}
  \rho(c) \wedge \rho(singleProperties(c)) \wedge \rho(collectionProperties(c)) \\ \wedge \rho(associations(c))
\end{gathered}
}
$$
\paragraph{Add Property} The function $AddProperty$ on level of database does not change the structure only, but it has an impact on stored data too. This is because a mandatory property can be added into a class with already existing instances, then a default value has to be added to all existing instances.
$$
\Phi_{AP}(p, d) = \begin{cases}
\inference{ \exists t \in tables(d) : name(t) = name(owningClass(p)) \\ \wedge (! mandatory(p) \vee ! instantiated(owningClass(p))}{ \rho(p,d)} 
\\ \\ 
\inference{ \exists t \in tables(d) : name(t) = name(owningClass(p)) \\ \wedge mandatory(p) \wedge instantiated(owningClass(p)) \\ \wedge cardinality(p) \leq 1}{\begin{gathered}
 \rho(p,d) \wedge \forall r \in data(d), reference(r) = t : pair(r) \\ \cup pair(name(p), defaultValue(p))
\end{gathered}
} 
\\ \\
\inference{ \exists t \in tables(d) : name(t) = name(owningClass(p)) \\ \wedge mandatory(p) \wedge instantiated(owningClass(p)) \\ \wedge cardinality(p) \leq 1}{\begin{gathered}
 \rho(p,d) \wedge \forall r \in row(owningClass(p)) : data(d)\\ \cup row(name(p), pair("value", defaultValue(p)), \\ pair(name(p), value(primaryKey(r))) 
\end{gathered}
} 

\end{cases}
$$

\paragraph{Add Association} Adding an association into a database is complicated because of already existing instances. When an association between classes is added the instances of both classes has to be paired. This pairing is provided by the function $f_m$:
$$f_m : Property \rightarrow Instance \times Instance $$

\textbf{TODO: define the features of the $f_m$}

The mapping of the $AddAssociation$ function is defined as:
$$
\Phi_{AA}(a, f_m, d) = \begin{cases}
\inference{ \exists t_s, t_t \in tables(d) : name(t_s) = name(owningClass(a)) \\ \wedge name(t_t) = reference(a) \\ \wedge \not \exists f \in foreignKeys(t_t) : name(f) = name(a) \\ startCardinality(a) \leq 1}{\begin{gathered}
\rho(a,d) \wedge \forall r \in f_m(owningClass(a), reference(a)) : \\ data(t_t) \cup row(name(t_s), pair(name(a), \\ value(primaryKey(first(r)))) 
\end{gathered}
 }
 \\ \\
\inference{ \exists t_s, t_t \in tables(d) : name(t_s) = name(owningClass(a)) \\ \wedge name(t_t) = reference(a) \\ \wedge \not \exists f \in foreignKeys(t_t) : name(f) = name(a) \\ startCardinality(a) > 1}{\begin{gathered}
\rho(a,d) \wedge \forall r \in f_m(owningClass(a), reference(a)),\\ t \in tables(d) : name(t) = name(a) : \\ data(t) \cup row(name(a), pair(name(t_s), \\ value(primaryKey(first(r)))) pair(name(t_t), \\ value(primaryKey(second(r)))))
\end{gathered}
 } 
 
 \end{cases}
$$

\subsubsection{Deconstruction of a Software}
\paragraph{Remove Class}
$$
\Phi_{RC}(c,d) = \inference{ \rho(c) \in tables(d) \\ \wedge \not \exists r \in data(d) : owningTable(r) = \rho(c) \\ \not \exists j \in tables(d), f \in foreignKeys(j) : reference(f) = \rho(c)  }{ tables(d) \setminus \rho(c)}
$$
%TODO remove by label

\paragraph{Remove Property}
$$
\Phi_{RP}(p, d) = \begin{cases}
 \inference{ \exists t \in tables(d) : name(t) = name(owningClass(p)) \\ \wedge \exists c \in columns(t) : name(c) = name(p) \\ \wedge \not \exists r \in data(d) : owningTable(r) = name(owningClass(p)) }{columns(t) \setminus c
} \\ \\
  \inference{ \exists t \in tables(d) : name(t) = name(owningClass(p)) \\ \wedge \not \exists c \in columns(t) : name(c) = name(p) \\ \wedge \exists u \in tables(d) : name(u) = name(p) \\ \wedge \not \exists r \in data(d) : owningTable(r) = name(owningClass(p))}{ tables(d) \setminus u }
 \end{cases}
$$

\paragraph{Remove Association}
$$
\Phi_{RA}(a, d) =  \begin{cases}
 \inference{\exists t \in tables(d) : name(t) = name(owningClass(a))
 \\ \wedge \exists f \in foreignKeys(t) : name(f) = name(a)
 \\ \wedge \forall r \in data(d) : owningTable(r) \neq t}{ foreignKeys(t) \setminus f }
 \\ \\
 \inference{\exists t \in tables(d) : name(t) = name(a)
 \\ \wedge \exists f \in foreignKeys(t) : name(f) = name(owningClass(a))
 \\ \wedge \forall r \in data(d) : owningTable(r) \neq t}{ tables(d) \setminus t}
 \end{cases}
$$

\subsubsection{Altering a Software}	
\paragraph{Copy Column}
$$\Phi_{copyC} : Label \times Label \times Label \times f_m \times Database \rightarrow Database $$

\begin{equation*}
	\begin{gathered}
		\Phi_{copyC}(l_c, l_s, l_t, f_m, d) = \begin{cases}
 		\inference{\exists t \in tables(d) : name(t) = l_s \\ \wedge \exists c \in columns(t) : name(c) = l_c \\ \wedge \exists e \in tables(d) : name(e) = l_t  \\ \wedge \forall q \in properties(e) : name(q) \neq l_c}{columns(e) \cup c \wedge \forall r \in rows(t) : f_m(r) \cup getPair(l_c,r)}
	\end{cases}
	\end{gathered}
\end{equation*}

\subsection{Composing of Evolution Operations}
\paragraph{Copy Property}
All transformations described earlier does change only the structure of a application. These operation can be used in case there are no instances in the application. If instances are present in the application, the decomposition transformations could cause a data lost. Therefore we define  the transformation for copying a property from one class to another. The copy property is the basic way to copy data from instance of a class to instance of another class.

The copy property can be implemented as a transformation composed by operations for adding and removing property, nevertheless this composition would not work with instances, thus we define the copy property operation as a basic and atomic operation which will help us to handle instances.

$$\rho_{copyP} : Label \times Label \times Label \times (Instance \times Instance) \times Application \rightarrow Application $$
\begin{equation*}
	\rho_{copy}(l_s, l_t, l_p, a) = \inference{\exists c \in classes(a) : name(c) = l_s \\ \wedge \exists p \in properties(c) : name(p) = l_p \\ \wedge \exists e \in classes(a) : name(e) = l_t  \\ \wedge \forall q \in properties(c) : name(q) \neq l_p}{\begin{gathered}
properites(e) \cup p 
\end{gathered}
}
\end{equation*}

With a copy property transformation defined we are able to define advanced evolution scenarios.

\paragraph{Change Cardinality}
$$\rho_{CcP} : Property \times \mathbb{N^{*}} \times Application \rightarrow Property $$
$$\rho_{cardA} : Association \times \mathbb{N^{*}} \times Application \rightarrow Association $$

\section{Summary}



\end{document}
% This is important in case we have an evolution consisting of several evolution operations. These operations has to be proceed in concrete order and all of them has to change the software otherwise the software can become inconsistent from user point of view (the structure or stored data will not correspond with the users' reality). To assure the right behavior of evolution operations and to propagate operations fail to the user we extend the definition of a software to make it a monad. The extension consists in defining a software state and operations $ret$ and $\oplus$ (called evolve), which is used as a concatenation of operations as well.
%
%Each evolution transformation has a definition: $Software \rightarrow State$ and all evolution transformations creates a set called $Transformations$, then a concatenation of evolution transformation is defined as:
%\begin{equation*}
%\begin{gathered}
% \oplus : State \times Transformations \rightarrow State  \\ \\
% u \oplus t = \begin{cases}
% u, \; u = Inconsistent \; s \\
% t(u), \; u = Consistent \; s 
%\end{cases}\\ 
%u \in States, t \in Transformations, s \in Softwares
%\end{gathered}
%\end{equation*}
%
% To describe these two aspects od software evolution we decide to define transformations for each layer separately. The separation of transformation contexts help us to define transformation specific for application or database evolution, which can ease both - understanding and defining the transformation. The transformations specific for a context are called operations and they creates two sets- first one for application evolution: $AppOps$  and second one for database evolution $DbOps$. Applying of a transformation is defined:
%\begin{gather*}
%u \oplus t = ret(<application(u) \oplus o_{app}, database(u) \oplus o_{db}>) \\
%u \in Softwares, t \in Transformations, o_{app} \in AppOps, o_{db} \in DbOps
%\end{gather*}