load ./sequence.maude

fmod AS is
	sort Bound .	
	sorts Class Association Property Type .
	
---NAT and "*"?	
	op |* : -> Bound [ctor] .	
	op |0 :	-> Bound [ctor] .
	op |1 : -> Bound [ctor] .
	
endfm

view Association from TRIV to AS is
	sort Elt to Association .
endv 

view Property from TRIV to AS is
	sort Elt to Property .
endv

view Class from TRIV to AS is
	sort Elt to Class .
endv

fmod AR is
	pr AS .
	pr QID .
	pr BOOL .
	pr SEQUENCE{Property} .
	pr SEQUENCE{Association} .
	
	op STRING : -> Type [ctor] .
	
--- Class = < label, property*, association* >
	op class : Qid List{Property} List{Association} -> Class [ctor] .
	op name : Class -> Qid .
	op properties : Class -> List{Property} .
	op associations : Class -> List{Association} .
	
--- Property = < label, type, defaultValue, ordered, unique, upperBound, lowerBound >
	op property : Qid Type String Bool Bool Bound Bound -> Property [ctor] .
	op name : Property -> Qid . 
	op type : Property -> Type .
	op defaultValue : Property -> String .
	op ordered : Property -> Bool .
	op unique : Property -> Bool .
	op upperBound : Property -> Bound .
	op lowwerBound : Property -> Bound . 
	
--- Association = < label, referencedClass, ordered, unique, upperBound, lowerBound 
	op association : Qid Qid Bool Bool Bound Bound -> Association [ctor] .
	op name : Association -> Qid .
	op referenceA : Association -> Qid .
	op ordered : Association -> Bool .
	op unique : Association -> Bool .
	op upperBound : Association -> Bound .
	op lowwerBound : Association -> Bound .
	
	
endfm

fmod APPDATA is
	pr AR .
	pr SEQUENCE{Qid} .
	pr SEQUENCE{String} .
	
	sorts PropertyValue AssociationValue .
	
--- propVal = < propertyName, values >	
	op propVal : Qid List{String} -> PropertyValue [ctor] .
	op reference : PropertyValue -> Qid .
	op val : PropertyValue -> List{String} .
	
--- asocVal = < accociationName, referencedInstancies >
	op assocVal : Qid List{Qid} -> AssociationValue [ctor] .
	op reference : AssociationValue -> Qid .
	op val : AssociationValue -> List{Qid} .
	
endfm

view PropertyValue from TRIV to APPDATA is
	sort Elt to PropertyValue .
endv

view AssociationValue from TRIV to APPDATA is
	sort Elt to AssociationValue .
endv

fmod IN is
	pr APPDATA .
	pr SEQUENCE{Class} .
	pr SEQUENCE{PropertyValue} .
	pr SEQUENCE{AssociationValue} . 
	
	sort Instance .

--- instance = < name, property*, association* >	
	op instance : Qid Qid List{PropertyValue} List{AssociationValue} -> Instance [ctor] .

	var As : List{Association} .
	var A : Association .
	var Cls : List{Class} .
	var C : Class .
	var Q N : Qid .
	var PVs : List{PropertyValue} .
	var AVs : List{AssociationValue} .
	

	op name : Instance -> Qid .
	eq name(instance(Q, N, PVs, AVs)) = Q .
	
	op ofClass : Instance -> Qid .
	eq ofClass(instance(Q, N, PVs, AVs)) = N .
	
	op props : Instance -> List{PropertyValue} .
	eq props(instance(Q, N, PVs, AVs)) = PVs .
	
	op assocs : Instance -> List{AssociationValue} .
	eq assocs(instance(Q, N, PVs, AVs)) = AVs .

--- HELPERS	
	op referencesExist : List{Association} List{Class} -> Bool .
	eq referencesExist([], Cls) = true .
	eq referencesExist(As, []) = false .
	eq referencesExist(A, C) = referenceA(A) == name(C) .
	eq referencesExist(As, Cls) = containsName(Cls, referenceA(head(As))) or referencesExist(tail(As), Cls) .

	op isAssociated : List{Class} Qid -> Bool .
	eq isAssociated([], Q) = false .
	eq isAssociated(Cls, Q) = associate(associations(Cls), Q) or isAssociated(tail(Cls), Q) . 
	
	op associate : List{Association} Qid -> Bool .
	eq associate([], Q) = false .
	eq associate(As, Q) = referenceA(head(As)) == Q or associate(tail(As), Q) . 
	
endfm

view Instance from TRIV to IN is
	sort Elt to Instance .
endv

fmod APP is
	pr IN .
	pr SEQUENCE{Instance} .
	
	
	sorts Application ErrApplication .
	subsort ErrApplication < Application .

--- application = < class*, instance* >	
	op application : List{Class} List{Instance} -> Application [ctor] .
	op errApplication : String Application -> ErrApplication [ctor] .

	var A : Application .
	var Classes : List{Class} .
	var Instances : List{Instance} .
	var C : Class .
	var Q : Qid . 
	
	op classes : Application -> List{Class} .
	eq classes(application(Classes, Instances)) = Classes .
	
	op instances : Application -> List{Instance} .
	eq instances(application(Classes, Instances)) = Instances .
	
--- addClass
	op addClass : Application Class -> Application .
	ceq addClass(A, C) = errApplication("Unable to add class - the name already exists", A) if containsName(classes(A), name(C)) .
	ceq addClass(A, C) = errApplication("Unable to add class - associed classes not exist(s)", A) if not referencesExist(associations(C), classes(A)) .
	eq addClass(A, C) = application(classes(A) C, instances(A)) .
	
--- removeClass
	op removeClass : Application Qid -> Application .
	ceq removeClass(A, Q) = errApplication("Unable to remove class - table not exists", A) if not containsName(classes(A), Q) . 
	ceq removeClass(A, Q) = errApplication("Unable to remove class - instances exists", A)  if instancesExist(instances(A), Q) .
--- should it be isReferencedByInstances?
	ceq removeClass(A, Q) = errApplication("Unable to remove class - class is referenced by an association", A)  if isAssociated(classes(A), Q) .
	eq removeClass(A, Q) = application(removeByName(classes(A), Q), instances(A)) .
	
	
--- addProperty

--- removeProperty	

--- HELPERS
	op instancesExist : List{Instance} Qid -> Bool .
	eq instancesExist([], Q) = false .
	eq instancesExist(Instances, Q) = (ofClass(head(Instances)) == Q) or instancesExist(tail(Instances), Q) .
	
	
endfm