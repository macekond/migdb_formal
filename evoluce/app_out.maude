load ./sequence.maude

fmod AS is
	sort Bound .	
	sorts Class Association Property PrimitiveCollection App-Type .
	
---NAT and "*"?	
	op |* : -> Bound [ctor] .	
	op |0 :	-> Bound [ctor] .
	op |1 : -> Bound [ctor] .
	
endfm

view Association from TRIV to AS is
	sort Elt to Association .
endv 

view Property from TRIV to AS is
	sort Elt to Property .
endv

view PrimitiveCollection from TRIV to AS is
	sort Elt to PrimitiveCollection .
endv

view Class from TRIV to AS is
	sort Elt to Class .
endv

fmod AR is
	pr AS .
	pr QID .
	pr BOOL .
	pr SEQUENCE{Property} .
	pr SEQUENCE{Association} .
	pr SEQUENCE{PrimitiveCollection} .
	
	op APP-STRING : -> App-Type [ctor] .
	
	var Q N : Qid . 
	var Props : List{Property} .
	var Collects : List{PrimitiveCollection} .
	var Assocs : List{Association} .
	var S : String .
	var T : App-Type .
	var B1 B2 B3 : Bool .
	var Bo : Bound .
	var C1 C2 : NzNat .
	
	
--- Class = < label, property*, primitiveCollection*, association* >
	op class : Qid List{Property} List{PrimitiveCollection} List{Association} -> Class [ctor] .
	op name : Class -> Qid .
	eq name(class(Q, Props, Collects, Assocs)) = Q .
	op properties : Class -> List{Property} .
	eq properties(class(Q, Props, Collects, Assocs)) = Props .
	op collections : Class -> List{PrimitiveCollection} .
	eq collections(class(Q, Props, Collects, Assocs)) = Collects .
	op associations : Class -> List{Association} .
	eq associations(class(Q, Props, Collects, Assocs)) = Assocs .
	
--- Property = < label, type, defaultValue, mandatory, unique >
	op property : Qid App-Type String Bool Bool -> Property [ctor] .
	op name : Property -> Qid . 
	eq name(property(Q, T, S, B1, B2)) = Q .
	op type : Property -> App-Type .
	eq type(property(Q, T, S, B1, B2)) = T .
	op defaultValue : Property -> String .
	eq defaultValue(property(Q, T, S, B1, B2)) = S .
	op mandatory : Property -> Bool .
	eq mandatory(property(Q, T, S, B1, B2)) = B1 .
	op unique : Property -> Bool .
	eq unique(property(Q, T, S, B1, B2)) = B2 .

--- PrimitiveCollection = < label, type, defaultValue, ordered, unique, upperBound, mandatory >
--- reduced to < label, type, defaultValue, mandatory > 
--- ordered wil cause another column with ordering information,
--- unique, mandatory and upperBound will lead to trigger or some application control
    op primitiveCollection : Qid App-Type String Bool -> PrimitiveCollection [ctor] .
	op name : PrimitiveCollection -> Qid . 
	eq name(primitiveCollection(Q, T, S, B1)) = Q .
	op type : PrimitiveCollection -> App-Type .
	eq type(primitiveCollection(Q, T, S, B1)) = T .
	op defaultValue : PrimitiveCollection -> String .
	eq defaultValue(primitiveCollection(Q, T, S, B1)) = S .
---	op ordered : PrimitiveCollection -> Bool .
---	eq ordered(primitiveCollection(Q, T, S, B1, B2, Bo, B3)) = B1 .
---	op unique : PrimitiveCollection -> Bool .
---	eq unique(primitiveCollection(Q, T, S, B1, B2, Bo, B3)) = B2 .
---	op upperBound : PrimitiveCollection -> Bound .
---	eq upperBound(primitiveCollection(Q, T, S, B1, B2, Bo, B3)) = Bo .
	op mandatory : PrimitiveCollection -> Bool . 
	eq mandatory(primitiveCollection(Q, T, S, B1)) = B1 .
	
--- Association = < label, referencedClass, startCardinality, endCardinality >
	op association : Qid Qid NzNat NzNat -> Association [ctor] .
	op name : Association -> Qid .
	eq name(association(Q, N, C1, C2)) = Q .
	op referenceA : Association -> Qid .
	eq referenceA(association(Q, N, C1, C2)) = N .
	op startCardinality : Association -> NzNat .
	eq startCardinality(association(Q, N, C1, C2)) = C1 .
	op endCardinality : Association -> NzNat .
	eq endCardinality(association(Q, N, C1, C2)) = C2 .
---	op ordered : Association -> Bool .
---	op unique : Association -> Bool .
---	op upperBound : Association -> Bound .
---	op lowwerBound : Association -> Bound .
	
	
endfm

fmod APPDATA is
	pr AR .
	pr SEQUENCE{Qid} .
	pr SEQUENCE{String} .
	
	sorts PropertyValue AssociationValue .
	
--- propVal = < propertyName, values >	
	op propVal : Qid List{String} -> PropertyValue [ctor] .
	op reference : PropertyValue -> Qid .
	op val : PropertyValue -> List{String} .
	
--- asocVal = < accociationName, referencedInstancies >
	op assocVal : Qid List{Qid} -> AssociationValue [ctor] .
	op reference : AssociationValue -> Qid .
	op val : AssociationValue -> List{Qid} .
	
endfm

view PropertyValue from TRIV to APPDATA is
	sort Elt to PropertyValue .
endv

view AssociationValue from TRIV to APPDATA is
	sort Elt to AssociationValue .
endv

fmod IN is
	pr APPDATA .
	pr SEQUENCE{Class} .
	pr SEQUENCE{PropertyValue} .
	pr SEQUENCE{AssociationValue} . 
	
	sort Instance .

--- instance = < name, property*, association* >	
	op instance : Qid Qid List{PropertyValue} List{AssociationValue} -> Instance [ctor] .

	var As : List{Association} .
	var A : Association .
	var Cls : List{Class} .
	var C : Class .
	var Q N : Qid .
	var PVs : List{PropertyValue} .
	var AVs : List{AssociationValue} .
	

	op name : Instance -> Qid .
	eq name(instance(Q, N, PVs, AVs)) = Q .
	
	op ofClass : Instance -> Qid .
	eq ofClass(instance(Q, N, PVs, AVs)) = N .
	
	op props : Instance -> List{PropertyValue} .
	eq props(instance(Q, N, PVs, AVs)) = PVs .
	
	op assocs : Instance -> List{AssociationValue} .
	eq assocs(instance(Q, N, PVs, AVs)) = AVs .

--- HELPERS	
	op referencesExist : List{Association} List{Class} -> Bool .
	eq referencesExist([], Cls) = true .
	eq referencesExist(As, []) = false .
	eq referencesExist(A, C) = referenceA(A) == name(C) .
	eq referencesExist(As, Cls) = containsName(Cls, referenceA(head(As))) or referencesExist(tail(As), Cls) .

	op isAssociated : List{Class} Qid -> Bool .
	eq isAssociated([], Q) = false .
	eq isAssociated(Cls, Q) = associate(associations(Cls), Q) or isAssociated(tail(Cls), Q) . 
	
	op associate : List{Association} Qid -> Bool .
	eq associate([], Q) = false .
	eq associate(As, Q) = referenceA(head(As)) == Q or associate(tail(As), Q) . 
	
endfm

view Instance from TRIV to IN is
	sort Elt to Instance .
endv

fmod APP is
	pr IN .
	pr SEQUENCE{Instance} .
	
	
	sorts Application ErrApplication .
	subsort ErrApplication < Application .

--- application = < class*, instance* >	
	op application : List{Class} List{Instance} -> Application [ctor] .
	op errApplication : String Application -> ErrApplication [ctor] .

	var A : Application .
	var Classes : List{Class} .
	var Instances : List{Instance} .
	var C : Class .
	var Q : Qid . 
	
	op classes : Application -> List{Class} .
	eq classes(application(Classes, Instances)) = Classes .
	
	op instances : Application -> List{Instance} .
	eq instances(application(Classes, Instances)) = Instances .
	
--- addClass
	op addClass : Class Application -> Application .
	ceq addClass(C, A) = errApplication("add class - the name already exists", A) if containsName(classes(A), name(C)) .
	ceq addClass(C, A) = errApplication("add class - associed classes not exist(s)", A) if not referencesExist(associations(C), classes(A)) .
	eq addClass(C, A) = application(classes(A) C, instances(A)) .
	
--- removeClass
	op removeClass : Application Qid -> Application .
	ceq removeClass(A, Q) = errApplication("remove class - table not exists", A) if not containsName(classes(A), Q) . 
	ceq removeClass(A, Q) = errApplication("remove class - instances exists", A)  if instancesExist(instances(A), Q) .
--- should it be isReferencedByInstances?
	ceq removeClass(A, Q) = errApplication("remove class - class is referenced by an association", A)  if isAssociated(classes(A), Q) .
	eq removeClass(A, Q) = application(removeByName(classes(A), Q), instances(A)) .
	
	
--- addProperty

--- removeProperty	


--- HELPERS
	op instancesExist : List{Instance} Qid -> Bool .
	eq instancesExist([], Q) = false .
	eq instancesExist(Instances, Q) = (ofClass(head(Instances)) == Q) or instancesExist(tail(Instances), Q) .
	
	
endfm